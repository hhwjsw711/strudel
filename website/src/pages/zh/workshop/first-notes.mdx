---
title: 第一个音符
layout: ../../../layouts/MainLayout.astro
---

import { MiniRepl } from '@src/docs/MiniRepl';
import { midi2note } from '@strudel/core/';
import Box from '@components/Box.astro';
import QA from '@components/QA';

# 第一个音符

现在我们来看看如何用 `note` 函数播放音符。

## 数字和音符

**用数字播放音符**

<MiniRepl
  client:visible
  tune={`note("48 52 55 59").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    Array(49)
      .fill()
      .map((_, i) => [midi2note(i + 36), i + 36]),
  )}
/>

<Box>

尝试不同的数字！

也试试小数，如 55.5（注意用 "." 而不是 ","）

</Box>

**用字母播放音符**

<MiniRepl
  client:visible
  tune={`note("c e g b").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(['c3', 'd3', 'e3', 'f3', 'g3', 'a3', 'b3'].map((n) => [n, n.split('')[0]]))}
/>

<Box>

尝试不同的字母（a - g）。

你能找到同时也是单词的旋律吗？提示：☕ 🙈 🧚

</Box>

**变音记号**

<MiniRepl
  client:visible
  tune={`note("db eb gb ab bb").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    ['db3', 'eb3', 'gb3', 'ab3', 'bb3'].map((n) => [n, n.split('').slice(0, 2).join('')]),
  )}
/>

<MiniRepl
  client:visible
  tune={`note("c# d# f# g# a#").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    ['c#3', 'd#3', 'f#3', 'g#3', 'a#3'].map((n) => [n, n.split('').slice(0, 2).join('')]),
  )}
/>

**其他八度**

<MiniRepl
  client:visible
  tune={`note("c2 e3 g4 b5").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    Array(49)
      .fill()
      .map((_, i) => [midi2note(i + 36), midi2note(i + 36)]),
  )}
/>

<Box>

尝试不同的八度（1-8）

</Box>

通常，不熟悉音符的人用数字比字母更容易。
因此，以下示例大多使用数字。
稍后我们还会看到一些技巧，让我们更容易播放相互匹配的音符。

## 改变声音

就像噪音声音一样，我们可以用 `sound` 改变音符的声音：

<MiniRepl client:visible tune={`note("36 43, 52 59 62 64").sound("piano")`} />

<Box>

试试一些声音：

- gm_electric_guitar_muted - 电吉他
- gm_acoustic_bass - 低音提琴
- gm_voice_oohs - 和弦
- gm_blown_bottle - 瓶子
- sawtooth - 锯齿波
- square - 方波
- triangle - 三角波
- bd, sd 或 hh 呢？
- 完全移除 `.sound('...')`

</Box>

**在声音之间切换**

<MiniRepl
  client:visible
  tune={`note("48 67 63 [62, 58]")
.sound("piano gm_electric_guitar_muted")`}
/>

**同时声音**

<MiniRepl
  client:visible
  tune={`note("48 67 63 [62, 58]")
.sound("piano, gm_electric_guitar_muted")`}
/>

<Box>

`note` 和 `sound` 中的模式被组合了！

我们稍后会看到更多组合模式的方法。

</Box>

## 更长的序列

**用 / 减慢序列**

<MiniRepl client:visible tune={`note("[36 34 41 39]/4").sound("gm_acoustic_bass")`} punchcard />

<Box>

`/4` 使序列慢 4 倍，总共 4 个周期 = 8s。

每个音符现在是 2s 长。

在括号中写更多音符，注意它变快了。

</Box>

如果序列无论内容如何都应保持相同速度，还有另一种括号：

**每个周期一个，用 < >**

在上一章，我们已经学到 `< ... >`（尖括号）每个周期只播放一个元素。
这对旋律也很有用：

<MiniRepl client:visible tune={`note("<36 34 41 39>").sound("gm_acoustic_bass")`} punchcard />

<Box>

添加更多音符，注意节奏保持不变！

实际上，这些括号只是缩写：

`<a b c>` = `[a b c]/3`

`<a b c d>` = `[a b c d]/4`

等等..

</Box>

**每个周期一个序列**

<MiniRepl
  client:visible
  tune={`note("<[36 48] [34 46] [41 53] [39 51]>")
.sound("gm_acoustic_bass")`}
  punchcard
/>

或者也...

<MiniRepl
  client:visible tune={`note("<[36 48]*4 [34 46]*4 [41 53]*4 [39 51]*4>/2")
.sound("gm_acoustic_bass")`}
  punchcard
/>

**替代品**

类似子序列，`<...>` 也可以在序列中使用：

<MiniRepl
  client:visible
  tune={`note("60 <63 62 65 63>")
.sound("gm_xylophone")`}
  punchcard
/>

这也适用于无调声音：

<MiniRepl
  client:visible
  tune={`sound("bd*2, ~ <sd cp>, [~ hh]*2")
.bank("RolandTR909")`}
  punchcard
/>

## 音阶

当所有音符都可用时，找到正确的音符可能很费力。
用音阶更容易：

<MiniRepl
  client:visible
  tune={`n("0 2 4 <[6,8] [7,9]>")
.scale("C:minor").sound("piano")`}
  punchcard
/>

<Box>

尝试不同的数字。每个都听起来不错！

尝试不同的音阶：

- C:major
- A2:minor
- D:dorian
- G:mixolydian
- A2:minor:pentatonic
- F:major:pentatonic

</Box>

**自动化音阶**

像所有函数一样，音阶也可以用模式自动化：

<MiniRepl
  client:visible
  tune={`n("<0 -3>, 2 4 <[6,8] [7,9]>")
.scale("<C:major D:mixolydian>/4")
.sound("piano")`}
  punchcard
/>

<Box>

如果你不知道音阶意味着什么，别担心。
它们只是不同组音符的名称，这些音符很好地匹配。

花时间找出你喜欢的音阶。

</Box>

## 重复和延长

**用 @ 延长**

<MiniRepl client:visible tune={`note("c@3 eb").sound("gm_acoustic_bass")`} punchcard />

<Box>

没有 `@` 的元素相当于 `@1`。在示例中，`c` 是三个单位长，`eb` 只有一个。

玩弄长度！

</Box>

**延长子序列**

<MiniRepl
  client:visible
  tune={`n("<[4@2 4] [5@2 5] [6@2 6] [5@2 5]>*2")
.scale("<C2:mixolydian F2:mixolydian>/4")
.sound("gm_acoustic_bass")`}
  punchcard
/>

<Box>

这个 Groove 也称为 `shuffle`。
每个节拍包含 2 个音符，其中第一个是第二个的两倍长。
这有时也称为 `triolen swing`。它是布鲁斯和爵士中的典型节奏。

</Box>

**重复**

<MiniRepl client:visible tune={`note("c!2 [eb,<g a bb a>]").sound("piano")`} punchcard />

<Box>

在 `!`、`*` 和 `@` 之间切换。

有什么区别？

</Box>

## 回顾

我们在这一章学到的：

| 概念      | 语法 | 示例                                                  |
| ------------ | ------ | -------------------------------------------------------- |
| 减慢 | \/     | <MiniRepl client:visible tune={`note("[c a f e]/2")`} /> |
| 替代品 | \<\>   | <MiniRepl client:visible tune={`note("c <e g>")`} />     |
| 延长   | @      | <MiniRepl client:visible tune={`note("c@3 e")`} />       |
| 重复  | !      | <MiniRepl client:visible tune={`note("c!3 e")`} />       |

新函数：

| 名称  | 描述                             | 示例                                                                           |
| ----- | --------------------------------------- | --------------------------------------------------------------------------------- |
| note  | 音高作为字母或数字         | <MiniRepl client:visible tune={`note("b g e c").sound("piano")`} />               |
| scale | 将 `n` 解释为音阶度       | <MiniRepl client:visible tune={`n("6 4 2 0").scale("C:minor").sound("piano")`} /> |
| stack | 并行播放多个模式（见下） | <MiniRepl client:visible tune={`stack(s("bd sd"),note("c eb g"))`} />             |

## 示例

**贝斯线**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
.sound("gm_synth_bass_1")
.lpf(800) // <-- we'll learn about this soon`}
/>

**旋律**

<MiniRepl
  client:visible
  tune={`n(\`<
[~ 0] 2 [0 2] [~ 2]
[~ 0] 1 [0 1] [~ 1]
[~ 0] 3 [0 3] [~ 3]
[~ 0] 2 [0 2] [~ 2]
>*2\`).scale("C4:minor")
.sound("gm_synth_strings_1")`}
/>

**鼓**

<MiniRepl
  client:visible
  tune={`sound("bd*2, ~ <sd cp>, [~ hh]*2")
.bank("RolandTR909")`}
/>

**如果有一种方法能同时播放这一切.......**

<Box>

可以用 `stack` 😙

</Box>

<MiniRepl
  client:visible
  tune={`stack(
  note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
  .sound("gm_synth_bass_1").lpf(800),
  n(\`<
  [~ 0] 2 [0 2] [~ 2]
  [~ 0] 1 [0 1] [~ 1]
  [~ 0] 3 [0 3] [~ 3]
  [~ 0] 2 [0 2] [~ 2]
  >*2\`).scale("C4:minor")
  .sound("gm_synth_strings_1"),
  sound("bd*2, ~ <sd cp>, [~ hh]*2")
  .bank("RolandTR909")
)`}
/>

这听起来越来越像真正的音乐了！
我们有声音，我们有音符.. 还缺一个拼图： [效果](/zh/workshop/first-effects)
